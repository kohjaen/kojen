/**
 * @file
 * @ingroup GROUP_EXAMPLE
 * @brief   An example demonstrating code-generation abilities.
 *          CDPlayer State Machine Test Suite. Run this in the console to manually test your state machine.
 *
 *          This code is Autogenerated from 'Transition Table' with the MIT License.
 *          As such, please only hand-code within 'USER' tags.
 *
 * @author  yourname@yourdomain.com
 */
#include "allplatforms/testsuite/minunit/minunit.h"
#include "CDPlayerStateMachine.h"

/// {{{USER_HEADER_INCLUDES}}}
#if ( defined(_MSC_VER) || defined(__GNUC__) || defined(__clang__) ) && !defined(__arm__)
#include <thread>
#include <chrono>
#endif

#ifdef __FREERTOS__
#define SM_THREAD_PRIORITY 4
#define SM_THREAD_STACK 500
#include "task.h"
#endif

void sleep_ms(long long ms_to_sleep)
{
#ifdef __arm__
#ifdef __FREERTOS__
    const TickType_t xDelay = ms_to_sleep / portTICK_PERIOD_MS;
    vTaskDelay(xDelay);
#else
#pragma message "Please define sleep for your RTOS here."
#endif // #ifdef __FREERTOS__
#else
    std::this_thread::sleep_for(std::chrono::milliseconds(ms_to_sleep));
#endif // #ifdef __arm__
}

/// {{{USER_HEADER_INCLUDES}}}

namespace CDPlayerSM_Test
{
    using namespace CDPlayerSM;

    class CTestCDPlayerController : public ICDPlayerController
    {
    public:

        virtual ~CTestCDPlayerController(){}

        /// @{ Guards
        virtual bool GuardCDInside() override
        {
            /// {{{USER_GuardCDInside}}}
            /// {{{USER_GuardCDInside}}}
            return ICDPlayerController::GuardCDInside();
        }
        virtual bool GuardCDHasMoreTracks() override
        {
            /// {{{USER_GuardCDHasMoreTracks}}}
            /// {{{USER_GuardCDHasMoreTracks}}}
            return ICDPlayerController::GuardCDHasMoreTracks();
        }
        virtual bool GuardCDHasNoMoreTracks() override
        {
            /// {{{USER_GuardCDHasNoMoreTracks}}}
            /// {{{USER_GuardCDHasNoMoreTracks}}}
            return ICDPlayerController::GuardCDHasNoMoreTracks();
        }
        virtual bool GuardCDHasPreviousTrack() override
        {
            /// {{{USER_GuardCDHasPreviousTrack}}}
            /// {{{USER_GuardCDHasPreviousTrack}}}
            return ICDPlayerController::GuardCDHasPreviousTrack();
        }
        /// @}
        /// @{ State Entry and Exit Overrides
        virtual void StateStop_on_entry() override
        {
            ICDPlayerController::StateStop_on_entry();
            /// {{{USER_StateStop_on_entry}}}
            /// {{{USER_StateStop_on_entry}}}
        }
        virtual void StateStop_on_exit() override
        {
            ICDPlayerController::StateStop_on_exit();
            /// {{{USER_StateStop_on_exit}}}
            /// {{{USER_StateStop_on_exit}}}
        }
        virtual void StateOpen_on_entry() override
        {
            ICDPlayerController::StateOpen_on_entry();
            /// {{{USER_StateOpen_on_entry}}}
            /// {{{USER_StateOpen_on_entry}}}
        }
        virtual void StateOpen_on_exit() override
        {
            ICDPlayerController::StateOpen_on_exit();
            /// {{{USER_StateOpen_on_exit}}}
            /// {{{USER_StateOpen_on_exit}}}
        }
        virtual void StatePlay_on_entry() override
        {
            ICDPlayerController::StatePlay_on_entry();
            /// {{{USER_StatePlay_on_entry}}}
            /// {{{USER_StatePlay_on_entry}}}
        }
        virtual void StatePlay_on_exit() override
        {
            ICDPlayerController::StatePlay_on_exit();
            /// {{{USER_StatePlay_on_exit}}}
            /// {{{USER_StatePlay_on_exit}}}
        }
        virtual void StatePause_on_entry() override
        {
            ICDPlayerController::StatePause_on_entry();
            /// {{{USER_StatePause_on_entry}}}
            /// {{{USER_StatePause_on_entry}}}
        }
        virtual void StatePause_on_exit() override
        {
            ICDPlayerController::StatePause_on_exit();
            /// {{{USER_StatePause_on_exit}}}
            /// {{{USER_StatePause_on_exit}}}
        }
        /// @}
        /// @{ Actions Override
        virtual void OnOpenDrive(EventOpen const& data) override
        {
            ICDPlayerController::OnOpenDrive(data);
            /// {{{USER_OnOpenDrive_EventOpen}}}
            /// {{{USER_OnOpenDrive_EventOpen}}}
        };
        virtual void OnPlayTrack(EventPlay const& data) override
        {
            ICDPlayerController::OnPlayTrack(data);
            /// {{{USER_OnPlayTrack_EventPlay}}}
            mu_assert_int_eq(m_expected_track_number, data.m_track_no);
            /// {{{USER_OnPlayTrack_EventPlay}}}
        };
        virtual void OnCloseDrive(EventOpen const& data) override
        {
            ICDPlayerController::OnCloseDrive(data);
            /// {{{USER_OnCloseDrive_EventOpen}}}
            /// {{{USER_OnCloseDrive_EventOpen}}}
        };
        virtual void OnPause(EventPlay const& data) override
        {
            ICDPlayerController::OnPause(data);
            /// {{{USER_OnPause_EventPlay}}}
            /// {{{USER_OnPause_EventPlay}}}
        };
        virtual void OnPlayNextTrack(EventEndOfTrack const& data) override
        {
            ICDPlayerController::OnPlayNextTrack(data);
            /// {{{USER_OnPlayNextTrack_EventEndOfTrack}}}
            /// {{{USER_OnPlayNextTrack_EventEndOfTrack}}}
        };
        virtual void OnStop(EventEndOfTrack const& data) override
        {
            ICDPlayerController::OnStop(data);
            /// {{{USER_OnStop_EventEndOfTrack}}}
            /// {{{USER_OnStop_EventEndOfTrack}}}
        };
        virtual void OnPlayNextTrack(EventSkipNextTrack const& data) override
        {
            ICDPlayerController::OnPlayNextTrack(data);
            /// {{{USER_OnPlayNextTrack_EventSkipNextTrack}}}
            /// {{{USER_OnPlayNextTrack_EventSkipNextTrack}}}
        };
        virtual void OnPlayPreviousTrack(EventSkipPreviousTrack const& data) override
        {
            ICDPlayerController::OnPlayPreviousTrack(data);
            /// {{{USER_OnPlayPreviousTrack_EventSkipPreviousTrack}}}
            /// {{{USER_OnPlayPreviousTrack_EventSkipPreviousTrack}}}
        };
        virtual void OnStop(EventStop const& data) override
        {
            ICDPlayerController::OnStop(data);
            /// {{{USER_OnStop_EventStop}}}
            /// {{{USER_OnStop_EventStop}}}
        };
        virtual void OnStop(EventAfter10Minutes const& data) override
        {
            ICDPlayerController::OnStop(data);
            /// {{{USER_OnStop_EventAfter10Minutes}}}
            /// {{{USER_OnStop_EventAfter10Minutes}}}
        };
        /// @}

        /// {{{USER_PUBLIC_MEMBERS}}}
        uint8_t m_expected_track_number;
        /// {{{USER_PUBLIC_MEMBERS}}}

        CTestCDPlayerController()
        {
            /// {{{USER_CConsoleCDPlayer_CONSTRUCTOR}}}
            m_expected_track_number = 0;
            /// {{{USER_CConsoleCDPlayer_CONSTRUCTOR}}}
        }
    };
}

struct sCDPlayer_Test_Suite_Fixture
{
    /// {{{USER_TEST_SUITE_FIXTURE_LOCALS}}}
    CDPlayerSM::ICDPlayerStateMachine* sm;
    CDPlayerSM_Test::CTestCDPlayerController controller;
    /// {{{USER_TEST_SUITE_FIXTURE_LOCALS}}}
    sCDPlayer_Test_Suite_Fixture(){
        /// {{{USER_TEST_SUITE_FIXTURE_SETUP}}}
#if defined(__FREERTOS__) && defined(THREADED)
        sm = CDPlayerSM::ICDPlayerStateMachine::Create(controller, SM_THREAD_PRIORITY, SM_THREAD_STACK);
#else
        sm = CDPlayerSM::ICDPlayerStateMachine::Create(controller);
#endif
        /// {{{USER_TEST_SUITE_FIXTURE_SETUP}}}
    }
    ~sCDPlayer_Test_Suite_Fixture(){
        /// {{{USER_TEST_SUITE_FIXTURE_TEARDOWN}}}
        delete sm;
        /// {{{USER_TEST_SUITE_FIXTURE_TEARDOWN}}}
    }
};

MU_TEST(TestCDPlayer_States)
{
    using namespace CDPlayerSM_Test;
    // This should be manually crafted to finely tune the state changes, forks etc (intricacies) of the SM
    /// {{{USER_UNIT_TEST_STATES}}}
    sCDPlayer_Test_Suite_Fixture fixture;

    const uint8_t NO_TRACKS = 10;
    mu_check(fixture.sm->IsStateStop());
    mu_check(!fixture.controller.GuardCDInside());
    // Open the CD player
    fixture.sm->TriggerEventOpen();
    sleep_ms(50);
    mu_check(fixture.sm->IsStateOpen());
    // Insert a CD and close the CD player
    fixture.sm->TriggerEventOpen();
    sleep_ms(50);
    // CD player motor closes the drive...an interrupt triggers that is close
    fixture.controller.SetHasCD(true);
    // Read the CD info...
    fixture.controller.SetTrackCount(NO_TRACKS);
    mu_check(fixture.sm->IsStateStop());
    mu_assert_int_eq(fixture.controller.GetTrackCount(), NO_TRACKS);
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 0);
    mu_check(fixture.controller.GuardCDInside());
    mu_check(fixture.controller.GuardCDHasMoreTracks());
    mu_check(!fixture.controller.GuardCDHasPreviousTrack());
    ///
    /// Test : Skipping forward and backward, pause and resume, then stopping somewhere in the middle.
    /// 
    // Play the first track...
    fixture.controller.m_expected_track_number = 1;
    fixture.sm->TriggerEventPlay(1);
    sleep_ms(50);
    mu_check(fixture.sm->IsStatePlay());
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 0);
    // end of track.
    fixture.sm->TriggerEventEndOfTrack();
    sleep_ms(50);
    mu_check(fixture.sm->IsStatePlay());
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 1);
    // end of track.
    fixture.sm->TriggerEventEndOfTrack();
    sleep_ms(50);
    mu_check(fixture.sm->IsStatePlay());
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 2);
    // skip next track
    fixture.sm->TriggerEventSkipNextTrack();
    sleep_ms(50);
    mu_check(fixture.sm->IsStatePlay());
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 3);
    // skip previous track
    fixture.sm->TriggerEventSkipPreviousTrack();
    sleep_ms(50);
    mu_check(fixture.sm->IsStatePlay());
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 2);
    // Pause. Shouldn't matter what track is passed...
    fixture.sm->TriggerEventPlay(99);
    sleep_ms(50);
    mu_check(fixture.sm->IsStatePause());
    // Resume
    fixture.controller.m_expected_track_number = 5;
    fixture.sm->TriggerEventPlay(5);
    sleep_ms(50);
    mu_check(fixture.sm->IsStatePlay());
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 2);
    // Stop
    fixture.sm->TriggerEventStop();
    sleep_ms(50);
    mu_check(fixture.sm->IsStateStop());
    // When stopping we cleared the current track...
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 0);
    ///
    /// Test : pause and automatic stop after 10 minutes.
    /// 
    fixture.controller.m_expected_track_number = 25;
    fixture.sm->TriggerEventPlay(25);
    sleep_ms(50);
    mu_check(fixture.sm->IsStatePlay());
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 0);
    // next track.
    fixture.sm->TriggerEventEndOfTrack();
    sleep_ms(50);
    mu_check(fixture.sm->IsStatePlay());
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 1);
    // pause. Shouldn't matter what track is played
    fixture.sm->TriggerEventPlay(99);
    sleep_ms(50);
    mu_check(fixture.sm->IsStatePause());
    // 10 minutes go by, and a timer interrupt signals this...
    fixture.sm->TriggerEventAfter10Minutes();
    sleep_ms(50);
    mu_check(fixture.sm->IsStateStop());
    // When stopping we cleared the current track...
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 0);
    ///
    /// Test : playing a whole CD goes to 'stop'.
    /// 
    fixture.controller.m_expected_track_number = 15;
    fixture.sm->TriggerEventPlay(15);
    sleep_ms(50);
    mu_check(fixture.sm->IsStatePlay());
    for (uint8_t i = 0; i <= NO_TRACKS; i++)
    {
        if (i < NO_TRACKS)
            mu_assert_int_eq(fixture.controller.GetCurrentTrack(), i);
        else
            mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 0);
        // end of track.
        fixture.sm->TriggerEventEndOfTrack();
        sleep_ms(50);
    }
    mu_check(fixture.sm->IsStateStop());
    // When stopping we cleared the current track...
    mu_assert_int_eq(fixture.controller.GetCurrentTrack(), 0);

    //
    //  Deferred play : i.e. close is pressed and play, before tray closes...
    //
    return;
    
    // Open the CD player
    fixture.sm->TriggerEventOpen();
    mu_check(fixture.sm->IsStateOpen());
    // Take out the CD
    fixture.controller.SetHasCD(false);
    // Insert a CD and close the CD player
    int t = sizeof(EventPlay);
    fixture.sm->TriggerEventPlay(99);
    // CD player motor closes the drive...an interrupt triggers that is close
    fixture.controller.SetHasCD(true);
    fixture.sm->TriggerEventOpen();
    mu_check(fixture.sm->IsStatePlay());

    /// {{{USER_UNIT_TEST_STATES}}}
}

/// {{{USER_TESTS}}}
/// {{{USER_TESTS}}}

MU_TEST_SUITE(CDPlayer_Suite) {
    MU_RUN_TEST(TestCDPlayer_States);
    // Don't forget to run your tests here.
    /// {{{USER_TEST_SUITE_TESTS}}}
    /// {{{USER_TEST_SUITE_TESTS}}}
}
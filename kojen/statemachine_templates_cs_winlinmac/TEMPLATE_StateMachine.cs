/**
 * @file
 * @ingroup <<<GROUP>>>
 * @brief   The state machine interface for the <<<STATEMACHINENAME>>>.
 * @detail  <<<BRIEF>>>
 *
 *          This statemachine has the following transition table:
 *
 *          <<<TTT_SML_BEGIN>>>
 *          <<<TTT_SML_END>>>
 *
 *          This code is Autogenerated from '<<<PYIFGENNAME>>>' with the MIT License.
 *          As such, please only hand-code within 'USER' tags.
 *
 * @author  <<<AUTHOR>>>
 */

#define SM_THREAD_<<<StateMachineThread::1>>>

using System.Threading;

namespace <<<NAMESPACE>>>
{
    /// <summary>
    /// <<<STATEMACHINENAME>>>StateMachine public implementation.
    /// </summary>
    public partial class <<<STATEMACHINENAME>>>StateMachine
    {
        public <<<STATEMACHINENAME>>>StateMachine(I<<<STATEMACHINENAME>>>Context context)
        {
            controller = context;
            Reset();
#if SM_THREAD_1
            dispatchThread = new Thread(new ThreadStart(Dispatch))
            {
                IsBackground = true
            };
            dispatchThread.Start();
#endif
        }
        <<<PER_STATE_BEGIN>>>
        /// <summary>
        /// Returns true if this statemachine is in the <<<STATENAME>>> state.
        /// </summary>
        public bool Is<<<STATENAME>>>()
        {
            return (estate == E<<<STATEMACHINENAME>>>State.<<<STATENAME>>>);
        }
        <<<PER_STATE_END>>>
        <<<PER_EVENT_BEGIN>>>
        /// <summary>
        /// Triggers the <<<EVENTNAME>>> event.
        /// </summary>
        public void Trigger<<<EVENTNAME>>>(<<<EVENTSIGNATURE>>>)
        {
            <<<EVENTNAME>>> evt = new ();
            <<<EVENTMEMBERSLITEINSTANTIATE::evt>>>
#if SM_THREAD_1
            dispatchQ.Enqueue(evt);
#else
            state.Trigger<<<EVENTNAME>>>(controller, this, evt);
#endif
        }
        <<<PER_EVENT_END>>>
    };
} // namespace <<<NAMESPACE>>>


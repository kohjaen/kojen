///  $URL$
///  $Author$
///  $Revision$
///  $Date$
///
/// \brief This is the <<<STATEMACHINENAME>>> Interface.
///
/// \author <<<AUTHOR>>>
/// \Code Autogenerated with MIT License.
///
/// This code is Autogenerated. For manual changes, use the 'USER_XXX' tag pairs for preservation of manual additions between round-trips.
///
#pragma once
#include "I<<<STATEMACHINENAME>>>Controller.h"
#include <memory>

#ifdef __FREERTOS__
#include "FreeRTOS.h"
#endif

/// {{{USER_HEADER_INCLUDES}}}
/// {{{USER_HEADER_INCLUDES}}}

/// {{{USER_FORWARD_DECLARATIONS}}}
/// {{{USER_FORWARD_DECLARATIONS}}}

namespace <<<NAMESPACE>>>
{
	/// {{{USER_LOCALS}}}
	/// {{{USER_LOCALS}}}

	class <<<DLL_EXPORT>>> I<<<STATEMACHINENAME>>>StateMachine
	{
	public:
		// The memory of what is returned is NEW'd. This means that you are responsible for it.
		// Luckily a SM is created once, and lives throughout the application lifetime, so 'free' should not be necessary.
#if defined(__FREERTOS__) && defined(THREADED)
        static I<<<STATEMACHINENAME>>>StateMachine* Create(I<<<STATEMACHINENAME>>>Controller* controller, unsigned portBASE_TYPE priority, unsigned portSHORT stackDepth=configMINIMAL_STACK_SIZE);
#else
        static I<<<STATEMACHINENAME>>>StateMachine* Create(I<<<STATEMACHINENAME>>>Controller* controller);
#endif // __FREERTOS__
		virtual ~I<<<STATEMACHINENAME>>>StateMachine(){};

		// Flag check
		<<<PER_STATE_BEGIN>>>
		virtual bool Is<<<STATENAME>>>() const = 0;
		<<<PER_STATE_END>>>

		// Event triggering
		virtual void TriggerEvent(std::unique_ptr<Event> data) = 0;

		/// {{{USER_PUBLIC_MEMBERS}}}
		/// {{{USER_PUBLIC_MEMBERS}}}
	protected:
		I<<<STATEMACHINENAME>>>StateMachine():m_controller(nullptr){};
		I<<<STATEMACHINENAME>>>Controller* m_controller;

		/// {{{USER_PROTECTED_MEMBERS}}}
		/// {{{USER_PROTECTED_MEMBERS}}}
	};
}
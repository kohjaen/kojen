///  $URL$
///  $Author$
///  $Revision$
///  $Date$
///
/// \brief This is the interface for the <<<STATEMACHINENAME>>> Controller.
///
/// \author <<<AUTHOR>>>
/// \Code Autogenerated with MIT License.
///
/// This code is Autogenerated. For manual changes, use the 'USER' tag pairs for preservation of manual additions between round-trips.
///
#pragma once

#ifdef __arm__
#include <allplatforms/allocator.h>
#endif //__arm__
#include <memory>
/// {{{USER_HEADER_INCLUDES}}}
/// {{{USER_HEADER_INCLUDES}}}

// For printouts.
//#define _OUT_<<<STATEMACHINENAME>>>_DISP_

/// {{{USER_FORWARD_DECLARATIONS}}}
/// {{{USER_FORWARD_DECLARATIONS}}}

namespace <<<NAMESPACE>>>
{
	/// {{{USER_LOCALS}}}
	/// {{{USER_LOCALS}}}

	//// Events //////////////////////////////
	/// @{ Events
	struct Event
	{
	public:
		virtual ~Event(){}
		Event(){};

		/** Move-only
		*/
		Event(const Event& other) = delete;
		Event& operator=(Event& other) = delete;
		Event(Event&& other) = default;
		Event& operator=(Event&& other) = default;
	};
	typedef std::unique_ptr<Event> Event_ptr;

	<<<PER_EVENT_BEGIN>>>
	struct <<<EVENTNAME>>> : public Event{
		/** Move-only
		*/
		<<<EVENTNAME>>>(const <<<EVENTNAME>>>& other) = delete;
		<<<EVENTNAME>>>& operator=(<<<EVENTNAME>>>& other) = delete;
		<<<EVENTNAME>>>(<<<EVENTNAME>>>&& other) = default;
		<<<EVENTNAME>>>& operator=(<<<EVENTNAME>>>&& other) = default;
		<<<EVENTNAME>>>(){};

	<<<EVENTMEMBERSDECLARE>>>
#ifdef __arm__    
	DECLARE_ALLOCATOR
#endif //__arm__    
	};
	typedef std::unique_ptr<<<<EVENTNAME>>>> <<<EVENTNAME>>>_ptr;

	<<<PER_EVENT_END>>>
	/// @}

	////Controller Interface //////////////////
	class <<<DLL_EXPORT>>> I<<<STATEMACHINENAME>>>Controller
	{
	public:
		virtual ~I<<<STATEMACHINENAME>>>Controller(){}

		/// @{ Guards
		<<<PER_GUARD_BEGIN>>>
		virtual bool <<<GUARDNAME>>>()
		{
			/// {{{USER_<<<GUARDNAME>>>}}}
			/// {{{USER_<<<GUARDNAME>>>}}}
#ifdef _OUT_<<<STATEMACHINENAME>>>_DISP_
			printf("I<<<STATEMACHINENAME>>>Controller : Guard >> <<<GUARDNAME>>> : %s \r\n", (m_<<<GUARDNAME>>>) ? ("True") : ("False"));
#endif
			return m_<<<GUARDNAME>>>;
		}
		<<<PER_GUARD_END>>>
		/// @}

		/// @{ State Entry and Exit
		<<<PER_STATE_BEGIN>>>
		virtual void <<<STATENAME>>>_on_entry()
		{
			/// {{{USER_<<<STATENAME>>>_on_entry}}}
			/// {{{USER_<<<STATENAME>>>_on_entry}}}
#ifdef _OUT_<<<STATEMACHINENAME>>>_DISP_
			printf("I<<<STATEMACHINENAME>>>Controller : State Enter >> <<<STATENAME>>> ...\r\n");
#endif
		}

		virtual void <<<STATENAME>>>_on_exit()
		{
			/// {{{USER_<<<STATENAME>>>_on_exit}}}
			/// {{{USER_<<<STATENAME>>>_on_exit}}}
#ifdef _OUT_<<<STATEMACHINENAME>>>_DISP_
			printf("I<<<STATEMACHINENAME>>>Controller : State Exit >> <<<STATENAME>>> ...\r\n");
#endif
		}
		<<<PER_STATE_END>>>
		/// @}

		/// @{ Actions
		<<<PER_ACTION_SIGNATURE_BEGIN>>>
		virtual void <<<ACTIONNAME>>>(<<<EVENTNAME>>> const& data)
		{
			/// {{{USER_<<<ACTIONNAME>>>_<<<EVENTNAME>>>}}}
			/// {{{USER_<<<ACTIONNAME>>>_<<<EVENTNAME>>>}}}
#ifdef _OUT_<<<STATEMACHINENAME>>>_DISP_
			printf("I<<<STATEMACHINENAME>>>Controller : Action >> <<<ACTIONNAME>>> on event <<<EVENTNAME>>> ... \r\n");
#endif
		};
		<<<PER_ACTION_SIGNATURE_END>>>
		/// @}

		/// {{{USER_PUBLIC_MEMBERS}}}
		/// {{{USER_PUBLIC_MEMBERS}}}

	protected:
		I<<<STATEMACHINENAME>>>Controller()
		{
			<<<PER_GUARD_BEGIN>>>
			m_<<<GUARDNAME>>> = false;
			<<<PER_GUARD_END>>>
			/// {{{USER_CONSTRUCTOR}}}
			/// {{{USER_CONSTRUCTOR}}}
		}

		<<<PER_GUARD_BEGIN>>>
		bool m_<<<GUARDNAME>>>;
		<<<PER_GUARD_END>>>

		/// {{{USER_PROTECTED_MEMBERS}}}
		/// {{{USER_PROTECTED_MEMBERS}}}
	};
}
/**
 * @file
 * @ingroup <<<GROUP>>>
 * @brief   <<<BRIEF>>>
 *
 *          This code is Autogenerated from '<<<PYIFGENNAME>>>' with the MIT License.
 *          As such, please only hand-code within 'USER' tags.
 *
 * @author  <<<AUTHOR>>>
 */
/// {{{USER_PCH}}}
/// {{{USER_PCH}}}
#include "I<<<STATEMACHINENAME>>>Controller.h"
#include "<<<STATEMACHINENAME>>>StateMachine.h"

#include <boost/msm-lite.hpp>

/// {{{USER_HEADER_INCLUDES}}}
/// {{{USER_HEADER_INCLUDES}}}

/// {{{USER_FORWARD_DECLARATIONS}}}
/// {{{USER_FORWARD_DECLARATIONS}}}

namespace msm = boost::msm::lite;

namespace {
    auto none = [] {};
    auto gnone = []{return true;};
}

namespace <<<NAMESPACE>>>
{
    /// {{{USER_LOCALS}}}
    /// {{{USER_LOCALS}}}

#ifdef __arm__
    //// Event custom allocators //////////////////////////////
    /// @{ Events (defined in I<<<STATEMACHINENAME>>>Controller.h
    <<<PER_EVENT_BEGIN>>>
    IMPLEMENT_ALLOCATOR(<<<EVENTNAME>>>, 0, 0)
    <<<PER_EVENT_END>>>
    /// @}
#endif //__arm__

    /// @{ States
    <<<PER_STATE_BEGIN>>>
    msm::state<class <<<STATENAME>>>>	<<<STATENAME>>>;
    <<<PER_STATE_END>>>

    ////////////////////////////////////////////////////////////
    // C<<<STATEMACHINENAME>>>StateMachine
    ////////////////////////////////////////////////////////////

    struct C<<<STATEMACHINENAME>>>StateMachine
    {
        /// @{ Guards
        <<<PER_GUARD_BEGIN>>>
        struct <<<GUARDNAME>>>
        {
            bool operator() (I<<<STATEMACHINENAME>>>Controller* controller)
            {
                if (controller)
                    return controller-><<<GUARDNAME>>>();
                return false;
            }
        };
        <<<PER_GUARD_END>>>
        /// @}

        /// @{ States
        <<<PER_STATE_BEGIN>>>
        struct <<<STATENAME>>>OnEntry{
            void operator()(I<<<STATEMACHINENAME>>>Controller* controller)
            {
                if (controller)
                    controller-><<<STATENAME>>>_on_entry();
            }
        };
        struct <<<STATENAME>>>OnExit{
            void operator()(I<<<STATEMACHINENAME>>>Controller* controller)
            {
                if (controller)
                    controller-><<<STATENAME>>>_on_exit();
            }
        };
        <<<PER_STATE_END>>>
        /// @{ Actions
        <<<PER_ACTION_BEGIN>>>
        struct <<<ACTIONNAME>>>
        {
            template <class Event>
            void operator() (I<<<STATEMACHINENAME>>>Controller* controller, Event & e)
            {
                if (controller)
                    controller-><<<ACTIONNAME>>>(e);
            }
        };
        <<<PER_ACTION_END>>>
        /// @}

        auto configure() const noexcept
        {
            using namespace msm;
            // State Entry/Exit Actions
            <<<PER_STATE_BEGIN>>>
            <<<STATENAME>>>OnEntry	__<<<STATENAME>>>OnEntry;
            <<<STATENAME>>>OnExit	__<<<STATENAME>>>OnExit;
            <<<PER_STATE_END>>>
            // Actions
            <<<PER_ACTION_BEGIN>>>
            <<<ACTIONNAME>>>		__<<<ACTIONNAME>>>;
            <<<PER_ACTION_END>>>
            // Guards
            <<<PER_GUARD_BEGIN>>>
            <<<GUARDNAME>>>			__<<<GUARDNAME>>>;
            <<<PER_GUARD_END>>>
            /// Transition table
            return make_transition_table(
                <<<TTT_BOOST_MSMLITE>>>
            );
        }
    };

    ////////////////////////////////////////////////////////////
    // C<<<STATEMACHINENAME>>>StateMachineImpl
    ////////////////////////////////////////////////////////////

    class C<<<STATEMACHINENAME>>>StateMachineImpl
        : public I<<<STATEMACHINENAME>>>StateMachine
    {
    public:
        virtual ~C<<<STATEMACHINENAME>>>StateMachineImpl()
        {
            delete m_sm;
        };
        C<<<STATEMACHINENAME>>>StateMachineImpl(I<<<STATEMACHINENAME>>>Controller* controller)
        {
            m_sm = new msm::sm<C<<<STATEMACHINENAME>>>StateMachine>(&(*controller));
        }

        <<<PER_STATE_BEGIN>>>
        virtual bool Is<<<STATENAME>>>() const override
        {
            return m_sm->is(<<<STATENAME>>>);
        }
        <<<PER_STATE_END>>>

        // Event triggering
        <<<PER_EVENT_BEGIN>>>
        //virtual void Trigger<<<EVENTNAME>>>(<<<SIGNATURE>>>) override
        /*{
            <<<EVENTNAME>>> data;
            <<<MEMBERSLITEINSTANTIATE>>>
            m_sm->process_event(data);
        }*/
        virtual void Trigger<<<EVENTNAME>>>(<<<EVENTNAME>>> *data) override
        {
            m_sm->process_event(*data);
        }
        <<<PER_EVENT_END>>>

        /// {{{USER_SMIMPL_PUBLIC_MEMBERS}}}
        /// {{{USER_SMIMPL_PUBLIC_MEMBERS}}}
    protected:
        msm::sm<C<<<STATEMACHINENAME>>>StateMachine> * m_sm;
    };

    ////////////////////////////////////////////////////////////
    // I<<<STATEMACHINENAME>>>StateMachine
    ////////////////////////////////////////////////////////////
    I<<<STATEMACHINENAME>>>StateMachine* I<<<STATEMACHINENAME>>>StateMachine::Create(I<<<STATEMACHINENAME>>>Controller* controller)
    {
        return new C<<<STATEMACHINENAME>>>StateMachineImpl(controller);
    }
}
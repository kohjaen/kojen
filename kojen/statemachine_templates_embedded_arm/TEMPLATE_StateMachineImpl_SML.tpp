/**
 * @file
 * @ingroup <<<GROUP>>>
 * @brief   <<<BRIEF>>>
 *
 *          This code is Autogenerated from '<<<PYIFGENNAME>>>' with the MIT License.
 *          As such, please only hand-code within 'USER' tags.
 *
 * @author  <<<AUTHOR>>>
 */
/// {{{USER_PCH}}}
/// {{{USER_PCH}}}
#include "I<<<STATEMACHINENAME>>>Controller.h"
#include "<<<STATEMACHINENAME>>>StateMachine.h"
#ifdef __FREERTOS__
#include "allplatforms/threaded_dispatcher_FreeRTOS.h"
#else
#include "allplatforms/threaded_dispatcher.h"
#endif

#include <boost/sml.hpp>

/// {{{USER_HEADER_INCLUDES}}}
/// {{{USER_HEADER_INCLUDES}}}

/// {{{USER_FORWARD_DECLARATIONS}}}
/// {{{USER_FORWARD_DECLARATIONS}}}

// this namespace is masqueraded as 'msm' due to the SML sharing parts of codegeneration with MSM. Makes for less messy scripts. Sorry.
namespace msm = boost::sml;

namespace boost{
    namespace msm {
        auto none = [] {};
        auto gnone = []{return true;};
    }
}

namespace {
    template <class R, class... Ts>
    auto call_impl(R(*f)(Ts...)) {
        return [f](Ts... args) { return f(args...); };
    }
    template <class T, class R, class... Ts>
    auto call_impl(T* self, R(T::*f)(Ts...)) {
        return [self, f](Ts... args) { return (self->*f)(args...); };
    }
    template <class T, class R, class... Ts>
    auto call_impl(const T* self, R(T::*f)(Ts...) const) {
        return [self, f](Ts... args) { return (self->*f)(args...); };
    }
    template <class T, class R, class... Ts>
    auto call_impl(const T* self, R(T::*f)(Ts...)) {
        return [self, f](Ts... args) { return (self->*f)(args...); };
    }
    /**
    * Simple wrapper to call free/member functions
    * @param args function, [optional] this
    * @return function(args...)
    */
    auto call = [](auto... args) { return call_impl(args...); };
}

namespace <<<NAMESPACE>>>
{
    /// {{{USER_LOCALS}}}
    /// {{{USER_LOCALS}}}

#ifdef __arm__
    //// Event custom allocators //////////////////////////////
    /// @{ Events (defined in I<<<STATEMACHINENAME>>>Controller.h
    <<<PER_EVENT_BEGIN>>>
    IMPLEMENT_ALLOCATOR(<<<EVENTNAME>>>, 0, 0)
    <<<PER_EVENT_END>>>
    /// @}
#endif //__arm__

    /// @{ States
    <<<PER_STATE_BEGIN>>>
    auto <<<STATENAME>>> = msm::state<class <<<STATENAME>>>>;
    <<<PER_STATE_END>>>

    ////////////////////////////////////////////////////////////
    // C<<<STATEMACHINENAME>>>StateMachine
    ////////////////////////////////////////////////////////////
    #define CONCRETE C<<<STATEMACHINENAME>>>StateMachine
    struct C<<<STATEMACHINENAME>>>StateMachine
    {
        /// @{ Guards
        <<<PER_GUARD_BEGIN>>>
        struct <<<GUARDNAME>>>
        {
            bool operator() (I<<<STATEMACHINENAME>>>Controller*& controller)
            {
                if (controller)
                    return controller-><<<GUARDNAME>>>();
                return false;
            }
        };
        <<<PER_GUARD_END>>>
        /// @}

        /// @{ States
        <<<PER_STATE_BEGIN>>>
        struct <<<STATENAME>>>OnEntry{
            void operator()(I<<<STATEMACHINENAME>>>Controller*& controller)
            {
                if (controller)
                    controller-><<<STATENAME>>>_on_entry();
            }
        };
        struct <<<STATENAME>>>OnExit{
            void operator()(I<<<STATEMACHINENAME>>>Controller*& controller)
            {
                if (controller)
                    controller-><<<STATENAME>>>_on_exit();
            }
        };
        <<<PER_STATE_END>>>
        /// @{ Actions
        <<<PER_ACTION_BEGIN>>>
        template <class Event>
        void <<<ACTIONNAME>>>(I<<<STATEMACHINENAME>>>Controller*& controller, const Event & e) const
        {
            if (controller)
                controller-><<<ACTIONNAME>>>(e);
        }
        <<<PER_ACTION_END>>>
        /// @}

        auto operator()() const noexcept
        {
            using namespace msm;
            // State Entry/Exit Actions
            <<<PER_STATE_BEGIN>>>
            <<<STATENAME>>>OnEntry	__<<<STATENAME>>>OnEntry;
            <<<STATENAME>>>OnExit	__<<<STATENAME>>>OnExit;
            <<<PER_STATE_END>>>
            // Guards
            <<<PER_GUARD_BEGIN>>>
            <<<GUARDNAME>>>			__<<<GUARDNAME>>>;
            <<<PER_GUARD_END>>>
            /// Transition table
            return make_transition_table(
                <<<TTT_LITE_SML_BEGIN>>>
                <<<TTT_LITE_SML_END>>>
            );
        }
    };

    ////////////////////////////////////////////////////////////
    // C<<<STATEMACHINENAME>>>StateMachineImpl
    ////////////////////////////////////////////////////////////

    class C<<<STATEMACHINENAME>>>StateMachineImpl
        : public I<<<STATEMACHINENAME>>>StateMachine
#ifdef THREADED
          ,public XKoJen::threaded_dispatcher<Event>
#endif // THREADED
    {
    public:

#if !defined(THREADED)
        typedef std::unique_ptr<Event> ptr_type;
#endif

        virtual ~C<<<STATEMACHINENAME>>>StateMachineImpl()
        {
            delete m_sm;
        };

#ifdef THREADED
    #ifdef __FREERTOS__
        explicit C<<<STATEMACHINENAME>>>StateMachineImpl(I<<<STATEMACHINENAME>>>Controller* controller, unsigned portBASE_TYPE priority, unsigned portSHORT stackDepth)
            : XKoJen::threaded_dispatcher<Event>("<<<STATEMACHINENAME>>> Dispatcher", priority, stackDepth)
    #else
        explicit C<<<STATEMACHINENAME>>>StateMachineImpl(I<<<STATEMACHINENAME>>>Controller* controller)
            : XKoJen::threaded_dispatcher<Event>("<<<STATEMACHINENAME>>> Dispatcher")
    #endif // __FREERTOS__
#else
        explicit C<<<STATEMACHINENAME>>>StateMachineImpl(I<<<STATEMACHINENAME>>>Controller* controller)
#endif //THREADED
        {
            m_sm = new msm::sm<C<<<STATEMACHINENAME>>>StateMachine>(&(*controller));
        }

        <<<PER_STATE_BEGIN>>>
        virtual bool Is<<<STATENAME>>>() const override
        {
            return m_sm->is(<<<STATENAME>>>);
        }
        <<<PER_STATE_END>>>

        // Event triggering

        virtual void TriggerEvent(std::unique_ptr<Event> event) override
        {
#ifdef THREADED
            dispatch(event);
#else
            handle_dispatch(std::move(event));
#endif
        }

        /// {{{USER_SMIMPL_PUBLIC_MEMBERS}}}
        /// {{{USER_SMIMPL_PUBLIC_MEMBERS}}}
    protected:
        msm::sm<C<<<STATEMACHINENAME>>>StateMachine> * m_sm;

#ifdef THREADED
        virtual void handle_dispatch(C<<<STATEMACHINENAME>>>StateMachineImpl::ptr_type item) override
#else
        void handle_dispatch(C<<<STATEMACHINENAME>>>StateMachineImpl::ptr_type item)
#endif
        {
            /// {{{USER_DISPATCH_EVENT_PROCESSING}}}
            /// {{{USER_DISPATCH_EVENT_PROCESSING}}}
            <<<PER_EVENT_BEGIN>>>
            if (<<<EVENTNAME>>>* data = dynamic_cast<<<<EVENTNAME>>>*>(item.get())){
                m_sm->process_event(*data);
                return;
            }
            <<<PER_EVENT_END>>>
        }
    };

    ////////////////////////////////////////////////////////////
    // I<<<STATEMACHINENAME>>>StateMachine
    ////////////////////////////////////////////////////////////
#if defined(__FREERTOS__) && defined(THREADED)
    I<<<STATEMACHINENAME>>>StateMachine* I<<<STATEMACHINENAME>>>StateMachine::Create(I<<<STATEMACHINENAME>>>Controller* controller, unsigned portBASE_TYPE priority, unsigned portSHORT stackDepth)
    {
        auto res = new C<<<STATEMACHINENAME>>>StateMachineImpl(controller, priority, stackDepth);
        res->Start();
        return res;
    }
#else
    I<<<STATEMACHINENAME>>>StateMachine* I<<<STATEMACHINENAME>>>StateMachine::Create(I<<<STATEMACHINENAME>>>Controller* controller)
    {
        return new C<<<STATEMACHINENAME>>>StateMachineImpl(controller);
    }
#endif // #ifdef __FREERTOS__
}
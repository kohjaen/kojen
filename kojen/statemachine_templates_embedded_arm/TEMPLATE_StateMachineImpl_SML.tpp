///  $Id: TEMPLATE_StateMachineImpl.tpp 726 2017-02-09 09:17:54Z eugene $
///
///
/// This code is Autogenerated. For manual changes, use the 'USER' tag pairs for preservation of manual additions between round-trips.
///
/// {{{USER_PCH}}}
/// {{{USER_PCH}}}
#include "I<<<STATEMACHINENAME>>>Controller.h"
#include "<<<STATEMACHINENAME>>>StateMachine.h"

#include <boost/sml.hpp>

/// {{{USER_HEADER_INCLUDES}}}
/// {{{USER_HEADER_INCLUDES}}}

/// {{{USER_FORWARD_DECLARATIONS}}}
/// {{{USER_FORWARD_DECLARATIONS}}}

namespace msm = boost::sml;

namespace boost{
	namespace msm {
		auto none = [] {};
		auto gnone = []{return true;};
	}
}

namespace {
	template <class R, class... Ts>
	auto call_impl(R(*f)(Ts...)) {
		return [f](Ts... args) { return f(args...); };
	}
	template <class T, class R, class... Ts>
	auto call_impl(T* self, R(T::*f)(Ts...)) {
		return [self, f](Ts... args) { return (self->*f)(args...); };
	}
	template <class T, class R, class... Ts>
	auto call_impl(const T* self, R(T::*f)(Ts...) const) {
		return [self, f](Ts... args) { return (self->*f)(args...); };
	}
	template <class T, class R, class... Ts>
	auto call_impl(const T* self, R(T::*f)(Ts...)) {
		return [self, f](Ts... args) { return (self->*f)(args...); };
	}
	/**
	* Simple wrapper to call free/member functions
	* @param args function, [optional] this
	* @return function(args...)
	*/
	auto call = [](auto... args) { return call_impl(args...); };
}

namespace <<<NAMESPACE>>>
{
	/// {{{USER_LOCALS}}}
	/// {{{USER_LOCALS}}}

#ifdef __arm__
	//// Event custom allocators //////////////////////////////
	/// @{ Events (defined in I<<<STATEMACHINENAME>>>Controller.h
	<<<PER_EVENT_BEGIN>>>
	IMPLEMENT_ALLOCATOR(<<<EVENTNAME>>>, 0, 0)
	<<<PER_EVENT_END>>>
	/// @}
#endif //__arm__

	/// @{ States
	<<<PER_STATE_BEGIN>>>
	auto <<<STATENAME>>> = msm::state<class <<<STATENAME>>>>;
	<<<PER_STATE_END>>>

	////////////////////////////////////////////////////////////
	// C<<<STATEMACHINENAME>>>StateMachine
	////////////////////////////////////////////////////////////
	#define CONCRETE C<<<STATEMACHINENAME>>>StateMachine
	struct C<<<STATEMACHINENAME>>>StateMachine
	{
		/// @{ Guards
		<<<PER_GUARD_BEGIN>>>
		struct <<<GUARDNAME>>>
		{
			bool operator() (I<<<STATEMACHINENAME>>>Controller* controller)
			{
				if (controller)
					return controller-><<<GUARDNAME>>>();
				return false;
			}
		};
		<<<PER_GUARD_END>>>
		/// @}

		/// @{ States
		<<<PER_STATE_BEGIN>>>
		struct <<<STATENAME>>>OnEntry{
			void operator()(I<<<STATEMACHINENAME>>>Controller* controller)
			{
				if (controller)
					controller-><<<STATENAME>>>_on_entry();
			}
		};
		struct <<<STATENAME>>>OnExit{
			void operator()(I<<<STATEMACHINENAME>>>Controller* controller)
			{
				if (controller)
					controller-><<<STATENAME>>>_on_exit();
			}
		};
		<<<PER_STATE_END>>>
		/// @{ Actions
		<<<PER_ACTION_BEGIN>>>
		template <class Event>
		void <<<ACTIONNAME>>>(I<<<STATEMACHINENAME>>>Controller* controller, const Event & e) const
		{
			if (controller)
				controller-><<<ACTIONNAME>>>(e);
		}
		<<<PER_ACTION_END>>>
		/// @}

		auto operator()() const noexcept
		{
			using namespace msm;
			// State Entry/Exit Actions
			<<<PER_STATE_BEGIN>>>
			<<<STATENAME>>>OnEntry	__<<<STATENAME>>>OnEntry;
			<<<STATENAME>>>OnExit	__<<<STATENAME>>>OnExit;
			<<<PER_STATE_END>>>
			// Guards
			<<<PER_GUARD_BEGIN>>>
			<<<GUARDNAME>>>			__<<<GUARDNAME>>>;
			<<<PER_GUARD_END>>>
			/// Transition table
			return make_transition_table(
				<<<TTT_LITE_SML_BEGIN>>>
				<<<TTT_LITE_SML_END>>>
			);
		}
	};

	////////////////////////////////////////////////////////////
	// C<<<STATEMACHINENAME>>>StateMachineImpl
	////////////////////////////////////////////////////////////

	class C<<<STATEMACHINENAME>>>StateMachineImpl
		: public I<<<STATEMACHINENAME>>>StateMachine
	{
	public:
		virtual ~C<<<STATEMACHINENAME>>>StateMachineImpl()
		{
			delete m_sm;
		};
		C<<<STATEMACHINENAME>>>StateMachineImpl(I<<<STATEMACHINENAME>>>Controller* controller)
		{
			m_sm = new msm::sm<C<<<STATEMACHINENAME>>>StateMachine>(&(*controller));
		}

		<<<PER_STATE_BEGIN>>>
		virtual bool Is<<<STATENAME>>>() const override
		{
			return m_sm->is(<<<STATENAME>>>);
		}
		<<<PER_STATE_END>>>

		// Event triggering
		<<<PER_EVENT_BEGIN>>>
		//virtual void Trigger<<<EVENTNAME>>>(<<<EVENTSIGNATURE>>>) override
		/*{
			<<<EVENTNAME>>> data;
			<<<EVENTMEMBERSLITEINSTANTIATE>>>
			m_sm->process_event(data);
		}*/
		virtual void Trigger<<<EVENTNAME>>>(<<<EVENTNAME>>> *data) override
		{
			m_sm->process_event(*data);
		}
		<<<PER_EVENT_END>>>

		/// {{{USER_SMIMPL_PUBLIC_MEMBERS}}}
		/// {{{USER_SMIMPL_PUBLIC_MEMBERS}}}
	protected:
		msm::sm<C<<<STATEMACHINENAME>>>StateMachine> * m_sm;
	};

	////////////////////////////////////////////////////////////
	// I<<<STATEMACHINENAME>>>StateMachine
	////////////////////////////////////////////////////////////
	I<<<STATEMACHINENAME>>>StateMachine* I<<<STATEMACHINENAME>>>StateMachine::Create(I<<<STATEMACHINENAME>>>Controller* controller)
	{
		return new C<<<STATEMACHINENAME>>>StateMachineImpl(controller);
	}
}